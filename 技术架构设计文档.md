# 模块化双模式技术架构设计文档

## 1. 项目概述

### 1.1 背景
随着数字化转型的深入，企业面临着不同的部署需求和业务场景。本项目旨在设计一个灵活的技术架构，既能够支持大规模的分布式微服务部署，又能够支持轻量级的本地化单体应用部署，实现业务代码在不同架构间的无缝迁移。

### 1.2 架构目标
- **灵活性**：支持微服务和单体两种部署模式
- **一致性**：业务逻辑在不同模式下保持一致
- **可扩展性**：支持水平扩展和垂直扩展
- **可维护性**：降低开发和运维复杂度
- **标准化**：建立统一的技术标准和开发规范

### 1.3 设计原则
- **模块化设计**：业务功能模块化，支持独立开发和部署
- **接口抽象**：通过抽象层屏蔽底层技术差异
- **配置驱动**：通过配置控制部署模式和运行时行为
- **容器化优先**：支持容器化部署和编排管理
- **云原生兼容**：兼容云原生技术和最佳实践

## 2. 架构设计选项

### 2.1 整体架构模式

#### 选项一：分层模块化架构（推荐）
```
┌─────────────────────────────────────────────────────────────┐
│                    前端展示层 (Frontend)                      │
├─────────────────────────────────────────────────────────────┤
│                    API 网关层 (Gateway)                      │
├─────────────────────────────────────────────────────────────┤
│                  业务服务层 (Business Services)               │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌──────────┐ │
│  │  用户服务    │ │  订单服务    │ │  支付服务    │ │  ...     │ │
│  │ User Service │ │Order Service│ │Payment Svc  │ │  其他服务 │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └──────────┘ │
├─────────────────────────────────────────────────────────────┤
│                   数据访问层 (Data Access)                   │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌──────────┐ │
│  │   MySQL     │ │    Redis    │ │  RabbitMQ   │ │  文件存储 │ │
│  │  (数据库)    │ │   (缓存)     │ │ (消息队列)   │ │  系统    │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └──────────┘ │
└─────────────────────────────────────────────────────────────┘
```

**优势：**
- 清晰的分层结构，职责分离
- 业务模块独立，易于维护和扩展
- 支持不同的部署模式
- 技术栈统一，降低学习成本

#### 选项二：微服务网格架构
```
┌─────────────────────────────────────────────────────────────┐
│                    前端应用 (Frontend Apps)                  │
├─────────────────────────────────────────────────────────────┤
│                   服务网格 (Service Mesh)                    │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌──────────┐ │
│  │   用户服务   │ │   订单服务   │ │   支付服务   │ │  其他服务 │ │
│  │ + 数据库     │ │ + 数据库     │ │ + 数据库     │ │ + 数据库  │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └──────────┘ │
├─────────────────────────────────────────────────────────────┤
│                   基础设施层 (Infrastructure)                │
└─────────────────────────────────────────────────────────────┘
```

**优势：**
- 完全去中心化，独立性强
- 支持大规模部署
- 故障隔离性好

**劣势：**
- 运维复杂度高
- 资源消耗大
- 不适合小规模部署

#### 选项三：单体模块化架构
```
┌─────────────────────────────────────────────────────────────┐
│                    前端应用 (Frontend)                      │
├─────────────────────────────────────────────────────────────┤
│                   单体应用 (Monolith App)                    │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                 Web 应用层                             │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐ │ │
│  │  │  用户模块    │ │  订单模块    │ │      支付模块        │ │ │
│  │  └─────────────┘ └─────────────┘ └─────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌──────────┐ │
│  │   MySQL     │ │    Redis    │ │   内存队列   │ │  文件系统 │ │
│  │  (数据库)    │ │   (缓存)     │ │ (消息队列)   │ │  存储    │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └──────────┘ │
└─────────────────────────────────────────────────────────────┘
```

**优势：**
- 部署简单，运维成本低
- 开发调试方便
- 适合小规模团队和项目

**劣势：**
- 扩展性受限
- 技术栈绑定严重
- 难以支持大规模部署

### 2.2 技术栈选择

#### 后端技术栈
- **核心框架**：Spring Boot 3.x + Spring Cloud 2023.x
- **编程语言**：Java 17+ / Kotlin
- **数据库**：MySQL 8.0+
- **缓存**：Redis 7.0+
- **消息队列**：RabbitMQ 3.12+ (微服务模式) / 内存队列 (单体模式)
- **API 文档**：OpenAPI 3.0 + Swagger
- **认证授权**：Spring Security + JWT

#### 前端技术栈
- **框架**：Vue 3.x / React 18.x
- **构建工具**：Vite / Webpack 5
- **UI 组件库**：Element Plus / Ant Design
- **状态管理**：Pinia / Redux Toolkit
- **HTTP 客户端**：Axios
- **路由**：Vue Router / React Router

#### 基础设施
- **容器化**：Docker + Docker Compose
- **编排平台**：K3s (轻量级 K8s)
- **网关**：Spring Cloud Gateway / Nginx
- **配置中心**：Spring Cloud Config / Nacos
- **服务发现**：Eureka / Nacos
- **监控**：Prometheus + Grafana
- **日志**：ELK Stack (Elasticsearch + Logstash + Kibana)

## 3. 详细架构设计

### 3.1 整体架构图

#### 微服务架构模式
```mermaid
graph TB
    subgraph "前端层"
        A[Web 前端应用]
        B[移动端应用]
        C[第三方应用]
    end

    subgraph "API 网关层"
        D[Spring Cloud Gateway]
    end

    subgraph "微服务层"
        E[用户服务]
        F[订单服务]
        G[支付服务]
        H[商品服务]
        I[通知服务]
    end

    subgraph "基础设施层"
        J[服务发现 Eureka]
        K[配置中心 Config]
        L[消息队列 RabbitMQ]
        M[数据库 MySQL]
        N[缓存 Redis]
    end

    subgraph "容器编排层"
        O[K3s Cluster]
        P[Docker 容器]
    end

    A --> D
    B --> D
    C --> D
    D --> E
    D --> F
    D --> G
    D --> H
    D --> I

    E --> J
    F --> J
    G --> J
    H --> J
    I --> J

    E --> K
    F --> K
    G --> K
    H --> K
    I --> K

    F --> L
    G --> L
    I --> L

    E --> M
    F --> M
    G --> M
    H --> M

    E --> N
    F --> N
    G --> N
    H --> N

    E --> P
    F --> P
    G --> P
    H --> P
    I --> P

    P --> O
```

#### 单体架构模式
```mermaid
graph TB
    subgraph "前端层"
        A[Web 前端应用]
        B[移动端应用]
        C[第三方应用]
    end

    subgraph "应用网关层"
        D[Nginx / Spring Gateway]
    end

    subgraph "单体应用层"
        E[Spring Boot 应用]
        F[用户模块]
        G[订单模块]
        H[支付模块]
        I[商品模块]
        J[通知模块]
    end

    subgraph "数据层"
        K[MySQL 数据库]
        L[Redis 缓存]
        M[内存消息队列]
        N[文件存储]
    end

    subgraph "容器层"
        O[Docker 容器]
        P[Docker Compose]
    end

    A --> D
    B --> D
    C --> D
    D --> E

    E --> F
    E --> G
    E --> H
    E --> I
    E --> J

    F --> K
    G --> K
    H --> K
    I --> K

    F --> L
    G --> L
    H --> L
    I --> L

    G --> M
    H --> M
    J --> M

    E --> N

    E --> O
    O --> P
```

### 3.2 核心组件设计

#### 3.2.1 业务服务抽象层

```java
// 业务服务基础接口
public interface BusinessService {
    /**
     * 获取服务配置信息
     */
    ServiceConfig getServiceConfig();

    /**
     * 健康检查
     */
    HealthStatus healthCheck();

    /**
     * 服务启动初始化
     */
    void initialize();
}

// 部署模式适配器接口
public interface DeploymentAdapter {
    /**
     * 获取消息队列实现
     */
    MessageQueue getMessageQueue();

    /**
     * 获取配置管理实现
     */
    ConfigManager getConfigManager();

    /**
     * 获取服务发现实现
     */
    ServiceDiscovery getServiceDiscovery();
}
```

#### 3.2.2 消息传递抽象层

```java
// 消息队列抽象接口
public interface MessageQueue {
    /**
     * 发送消息
     */
    void send(String topic, Object message);

    /**
     * 接收消息
     */
    void subscribe(String topic, MessageHandler handler);

    /**
     * 创建事务消息
     */
    TransactionMessage beginTransaction();
}

// 微服务模式实现
@Component("rabbitmqMessageQueue")
public class RabbitMQMessageQueue implements MessageQueue {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Override
    public void send(String topic, Object message) {
        rabbitTemplate.convertAndSend(topic, message);
    }

    // 其他实现...
}

// 单体模式实现
@Component("inMemoryMessageQueue")
public class InMemoryMessageQueue implements MessageQueue {
    private final Map<String, List<MessageHandler>> subscribers = new ConcurrentHashMap<>();

    @Override
    public void send(String topic, Object message) {
        List<MessageHandler> handlers = subscribers.get(topic);
        if (handlers != null) {
            handlers.forEach(handler -> handler.handle(message));
        }
    }

    // 其他实现...
}
```

#### 3.2.3 配置管理抽象层

```java
// 配置管理接口
public interface ConfigManager {
    /**
     * 获取配置值
     */
    String getConfig(String key, String defaultValue);

    /**
     * 获取配置对象
     */
    <T> T getConfig(String key, Class<T> type);

    /**
     * 监听配置变化
     */
    void addConfigListener(String key, ConfigListener listener);
}

// 配置策略工厂
@Component
public class ConfigManagerFactory {
    @Autowired
    private ApplicationContext applicationContext;

    public ConfigManager getConfigManager(DeploymentMode mode) {
        switch (mode) {
            case MICROSERVICE:
                return applicationContext.getBean("cloudConfigManager", ConfigManager.class);
            case MONOLITH:
                return applicationContext.getBean("localConfigManager", ConfigManager.class);
            default:
                throw new IllegalArgumentException("Unsupported deployment mode: " + mode);
        }
    }
}
```

### 3.3 数据层设计

#### 3.3.1 数据库设计原则
- **数据库独立性**：每个业务模块使用独立的数据库 schema
- **读写分离**：支持主从复制和读写分离
- **分库分表**：支持水平分片策略
- **数据一致性**：通过分布式事务或最终一致性保证

#### 3.3.2 缓存策略
```java
// 缓存抽象层
@Component
public abstract class CacheManager {
    /**
     * 设置缓存
     */
    public abstract void set(String key, Object value, long ttl);

    /**
     * 获取缓存
     */
    public abstract <T> T get(String key, Class<T> type);

    /**
     * 删除缓存
     */
    public abstract void delete(String key);

    /**
     * 批量操作
     */
    public abstract void batchSet(Map<String, Object> values, long ttl);
}

// Redis 实现
@Service
public class RedisCacheManager extends CacheManager {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Override
    public void set(String key, Object value, long ttl) {
        redisTemplate.opsForValue().set(key, value, ttl, TimeUnit.SECONDS);
    }

    // 其他实现...
}

// 本地缓存实现
@Service
@ConditionalOnProperty(name = "deployment.mode", havingValue = "monolith")
public class LocalCacheManager extends CacheManager {
    private final Cache<String, Object> cache = Caffeine.newBuilder()
        .maximumSize(10000)
        .expireAfterWrite(10, TimeUnit.MINUTES)
        .build();

    @Override
    public void set(String key, Object value, long ttl) {
        cache.put(key, value);
    }

    // 其他实现...
}
```

### 3.4 前后端分离设计

#### 3.4.1 API 设计规范
- **RESTful API**：遵循 REST 设计原则
- **统一响应格式**：
```json
{
  "code": 200,
  "message": "success",
  "data": {},
  "timestamp": "2024-01-01T00:00:00Z",
  "traceId": "abc123"
}
```

- **错误处理规范**：
```json
{
  "code": 400,
  "message": "参数错误",
  "errors": [
    {
      "field": "username",
      "message": "用户名不能为空"
    }
  ],
  "timestamp": "2024-01-01T00:00:00Z",
  "traceId": "abc123"
}
```

#### 3.4.2 前端架构设计
```
frontend/
├── src/
│   ├── components/          # 通用组件
│   ├── views/              # 页面组件
│   ├── store/              # 状态管理
│   ├── api/                # API 接口
│   ├── utils/              # 工具函数
│   ├── router/             # 路由配置
│   └── assets/             # 静态资源
├── public/                 # 公共文件
├── package.json
└── vite.config.js          # 构建配置
```

## 4. 部署架构设计

### 4.1 微服务部署模式

#### 4.1.1 K3s 集群部署
```yaml
# namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: business-apps

---
# user-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  namespace: business-apps
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: user-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "microservice"
        - name: EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE
          value: "http://eureka:8761/eureka"
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10

---
apiVersion: v1
kind: Service
metadata:
  name: user-service
  namespace: business-apps
spec:
  selector:
    app: user-service
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: user-service-ingress
  namespace: business-apps
spec:
  rules:
  - host: user-service.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 8080
```

#### 4.1.2 Docker Compose 部署
```yaml
# docker-compose.microservice.yml
version: '3.8'

services:
  eureka:
    image: springcloud/eureka:latest
    ports:
      - "8761:8761"
    environment:
      - SPRING_PROFILES_ACTIVE=docker

  config-server:
    image: config-server:latest
    ports:
      - "8888:8888"
    depends_on:
      - eureka
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka:8761/eureka

  rabbitmq:
    image: rabbitmq:3.12-management
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=admin123

  mysql:
    image: mysql:8.0
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=root123
      - MYSQL_DATABASE=business
    volumes:
      - mysql_data:/var/lib/mysql

  redis:
    image: redis:7.0-alpine
    ports:
      - "6379:6379"

  user-service:
    image: user-service:latest
    ports:
      - "8081:8080"
    depends_on:
      - eureka
      - config-server
      - mysql
      - redis
      - rabbitmq
    environment:
      - SPRING_PROFILES_ACTIVE=microservice,docker
      - EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka:8761/eureka
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/business
      - SPRING_REDIS_HOST=redis
      - SPRING_RABBITMQ_HOST=rabbitmq

  order-service:
    image: order-service:latest
    ports:
      - "8082:8080"
    depends_on:
      - eureka
      - config-server
      - mysql
      - redis
      - rabbitmq
    environment:
      - SPRING_PROFILES_ACTIVE=microservice,docker
      - EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka:8761/eureka
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/business
      - SPRING_REDIS_HOST=redis
      - SPRING_RABBITMQ_HOST=rabbitmq

  api-gateway:
    image: api-gateway:latest
    ports:
      - "8080:8080"
    depends_on:
      - eureka
      - user-service
      - order-service
    environment:
      - SPRING_PROFILES_ACTIVE=microservice,docker
      - EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka:8761/eureka

volumes:
  mysql_data:
```

### 4.2 单体应用部署模式

#### 4.2.1 Docker Compose 部署
```yaml
# docker-compose.monolith.yml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=root123
      - MYSQL_DATABASE=business
    volumes:
      - mysql_data:/var/lib/mysql
    command: --default-authentication-plugin=mysql_native_password

  redis:
    image: redis:7.0-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

  business-app:
    image: business-app:latest
    ports:
      - "8080:8080"
    depends_on:
      - mysql
      - redis
    environment:
      - SPRING_PROFILES_ACTIVE=monolith,docker
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/business
      - SPRING_REDIS_HOST=redis
      - DEPLOYMENT_MODE=MONOLITH
    volumes:
      - app_logs:/app/logs
      - app_upload:/app/upload
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - business-app
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
      - web_static:/usr/share/nginx/html
    restart: unless-stopped

volumes:
  mysql_data:
  redis_data:
  app_logs:
  app_upload:
  web_static:
```

#### 4.2.2 Nginx 配置
```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream business_app {
        server business-app:8080;
    }

    # 前端静态文件服务
    server {
        listen 80;
        server_name example.com;

        # 前端文件
        location / {
            root /usr/share/nginx/html;
            index index.html;
            try_files $uri $uri/ /index.html;
        }

        # API 代理
        location /api/ {
            proxy_pass http://business_app/api/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # WebSocket 支持
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        # 文件上传
        location /upload/ {
            proxy_pass http://business_app/upload/;
            client_max_body_size 100M;
        }
    }
}
```

### 4.3 环境配置管理

#### 4.3.1 配置文件结构
```
src/main/resources/
├── application.yml                 # 基础配置
├── application-microservice.yml    # 微服务模式配置
├── application-monolith.yml        # 单体模式配置
├── application-docker.yml          # Docker 环境配置
├── application-local.yml           # 本地开发配置
└── config/
    ├── rabbitmq.yml               # RabbitMQ 配置
    ├── redis.yml                  # Redis 配置
    ├── mysql.yml                  # MySQL 配置
    └── security.yml               # 安全配置
```

#### 4.3.2 动态配置示例
```yaml
# application.yml
spring:
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:local}

  application:
    name: business-service

# 部署模式配置
deployment:
  mode: ${DEPLOYMENT_MODE:MONOLITH}

# 消息队列配置
message:
  queue:
    type: ${MESSAGE_QUEUE_TYPE:IN_MEMORY}  # RABBITMQ / IN_MEMORY

---
# application-microservice.yml
spring:
  profiles: microservice

  cloud:
    consul:
      host: ${CONSUL_HOST:localhost}
      port: ${CONSUL_PORT:8500}
    stream:
      binders:
        rabbit:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: ${RABBITMQ_HOST:localhost}
                port: ${RABBITMQ_PORT:5672}
                username: ${RABBITMQ_USERNAME:guest}
                password: ${RABBITMQ_PASSWORD:guest}

---
# application-monolith.yml
spring:
  profiles: monolith

  # 内存队列配置
  queue:
    in-memory:
      max-size: 10000
      timeout: 5000

---
# application-docker.yml
spring:
  profiles: docker

  datasource:
    url: jdbc:mysql://${DB_HOST:mysql}:${DB_PORT:3306}/${DB_NAME:business}?useSSL=false&serverTimezone=UTC
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:root123}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5

  redis:
    host: ${REDIS_HOST:redis}
    port: ${REDIS_PORT:6379}
    timeout: 3000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
```

## 5. 实施指南

### 5.1 开发环境搭建

#### 5.1.1 本地开发环境
```bash
# 1. 安装必要软件
# - JDK 17+
# - Maven 3.8+
# - Node.js 16+
# - Docker & Docker Compose
# - Git

# 2. 克隆项目
git clone https://github.com/company/business-platform.git
cd business-platform

# 3. 启动基础设施
docker-compose -f docker-compose.dev.yml up -d mysql redis rabbitmq

# 4. 启动后端服务
cd backend
mvn spring-boot:run -Dspring-boot.run.profiles=local,monolith

# 5. 启动前端应用
cd frontend
npm install
npm run dev
```

#### 5.1.2 开发工具配置
```xml
<!-- .vscode/settings.json -->
{
  "java.configuration.updateBuildConfiguration": "automatic",
  "java.compile.nullAnalysis.mode": "automatic",
  "spring-boot.ls.checkJVM": false,
  "editor.formatOnSave": true,
  "files.autoSave": "afterDelay",
  "files.autoSaveDelay": 1000
}
```

### 5.2 代码规范和标准

#### 5.2.1 后端代码规范
```java
// 实体类示例
@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false, length = 100)
    private String email;

    @Column(nullable = false, length = 255)
    private String password;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Enumerated(EnumType.STRING)
    private UserStatus status;
}

// 服务层示例
@Service
@Transactional
@Slf4j
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private MessageQueue messageQueue;

    public UserDTO createUser(CreateUserRequest request) {
        log.info("Creating user: {}", request.getUsername());

        // 参数校验
        validateCreateUserRequest(request);

        // 检查用户名是否存在
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new BusinessException("用户名已存在");
        }

        // 创建用户
        User user = User.builder()
            .username(request.getUsername())
            .email(request.getEmail())
            .password(passwordEncoder.encode(request.getPassword()))
            .status(UserStatus.ACTIVE)
            .build();

        user = userRepository.save(user);

        // 发送用户创建事件
        UserCreatedEvent event = UserCreatedEvent.builder()
            .userId(user.getId())
            .username(user.getUsername())
            .email(user.getEmail())
            .createdAt(user.getCreatedAt())
            .build();

        messageQueue.send("user.created", event);

        return UserDTO.from(user);
    }

    private void validateCreateUserRequest(CreateUserRequest request) {
        Assert.notNull(request, "请求参数不能为空");
        Assert.hasText(request.getUsername(), "用户名不能为空");
        Assert.hasText(request.getEmail(), "邮箱不能为空");
        Assert.hasText(request.getPassword(), "密码不能为空");

        if (request.getUsername().length() < 3 || request.getUsername().length() > 50) {
            throw new BusinessException("用户名长度必须在3-50个字符之间");
        }

        if (!Pattern.matches("^[A-Za-z0-9_]+$", request.getUsername())) {
            throw new BusinessException("用户名只能包含字母、数字和下划线");
        }

        if (!Pattern.matches("^[A-Za-z0-9+_.-]+@(.+)$", request.getEmail())) {
            throw new BusinessException("邮箱格式不正确");
        }
    }
}

// 控制器示例
@RestController
@RequestMapping("/api/users")
@Validated
@Slf4j
public class UserController {

    @Autowired
    private UserService userService;

    @PostMapping
    public ApiResponse<UserDTO> createUser(@Valid @RequestBody CreateUserRequest request) {
        UserDTO userDTO = userService.createUser(request);
        return ApiResponse.success(userDTO);
    }

    @GetMapping("/{id}")
    public ApiResponse<UserDTO> getUser(@PathVariable Long id) {
        UserDTO userDTO = userService.getUser(id);
        return ApiResponse.success(userDTO);
    }

    @GetMapping
    public ApiResponse<PageResult<UserDTO>> listUsers(
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String keyword) {

        PageRequest pageRequest = PageRequest.of(page - 1, size);
        PageResult<UserDTO> result = userService.listUsers(pageRequest, keyword);
        return ApiResponse.success(result);
    }

    @PutMapping("/{id}")
    public ApiResponse<UserDTO> updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UpdateUserRequest request) {
        UserDTO userDTO = userService.updateUser(id, request);
        return ApiResponse.success(userDTO);
    }

    @DeleteMapping("/{id}")
    public ApiResponse<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ApiResponse.success();
    }
}
```

#### 5.2.2 前端代码规范
```javascript
// API 服务示例
// src/api/user.js
import request from '@/utils/request'

export const userApi = {
  // 创建用户
  createUser(data) {
    return request({
      url: '/api/users',
      method: 'post',
      data
    })
  },

  // 获取用户详情
  getUser(id) {
    return request({
      url: `/api/users/${id}`,
      method: 'get'
    })
  },

  // 获取用户列表
  listUsers(params) {
    return request({
      url: '/api/users',
      method: 'get',
      params
    })
  },

  // 更新用户
  updateUser(id, data) {
    return request({
      url: `/api/users/${id}`,
      method: 'put',
      data
    })
  },

  // 删除用户
  deleteUser(id) {
    return request({
      url: `/api/users/${id}`,
      method: 'delete'
    })
  }
}

// Vue 组件示例
<!-- src/views/user/UserList.vue -->
<template>
  <div class="user-list">
    <!-- 搜索栏 -->
    <div class="search-bar">
      <el-form :inline="true" :model="searchForm" class="search-form">
        <el-form-item label="关键词">
          <el-input
            v-model="searchForm.keyword"
            placeholder="请输入用户名或邮箱"
            clearable
            @keyup.enter="handleSearch"
          />
        </el-form-item>
        <el-form-item>
          <el-button type="primary" @click="handleSearch">搜索</el-button>
          <el-button @click="handleReset">重置</el-button>
        </el-form-item>
      </el-form>

      <el-button type="primary" @click="handleCreate" class="create-btn">
        新增用户
      </el-button>
    </div>

    <!-- 数据表格 -->
    <el-table
      v-loading="loading"
      :data="userList"
      style="width: 100%"
      border
    >
      <el-table-column prop="id" label="ID" width="80" />
      <el-table-column prop="username" label="用户名" />
      <el-table-column prop="email" label="邮箱" />
      <el-table-column prop="status" label="状态">
        <template #default="{ row }">
          <el-tag :type="row.status === 'ACTIVE' ? 'success' : 'danger'">
            {{ row.status === 'ACTIVE' ? '激活' : '禁用' }}
          </el-tag>
        </template>
      </el-table-column>
      <el-table-column prop="createdAt" label="创建时间">
        <template #default="{ row }">
          {{ formatDate(row.createdAt) }}
        </template>
      </el-table-column>
      <el-table-column label="操作" width="200">
        <template #default="{ row }">
          <el-button type="primary" size="small" @click="handleEdit(row)">
            编辑
          </el-button>
          <el-button type="danger" size="small" @click="handleDelete(row)">
            删除
          </el-button>
        </template>
      </el-table-column>
    </el-table>

    <!-- 分页 -->
    <el-pagination
      v-model:current-page="pagination.page"
      v-model:page-size="pagination.size"
      :total="pagination.total"
      :page-sizes="[10, 20, 50, 100]"
      layout="total, sizes, prev, pager, next, jumper"
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
      class="pagination"
    />

    <!-- 用户表单对话框 -->
    <UserForm
      v-model:visible="formVisible"
      :user="currentUser"
      @success="handleFormSuccess"
    />
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { userApi } from '@/api/user'
import UserForm from './UserForm.vue'
import { formatDate } from '@/utils/date'

// 响应式数据
const loading = ref(false)
const userList = ref([])
const formVisible = ref(false)
const currentUser = ref(null)

// 搜索表单
const searchForm = reactive({
  keyword: ''
})

// 分页数据
const pagination = reactive({
  page: 1,
  size: 10,
  total: 0
})

// 方法定义
const loadUserList = async () => {
  loading.value = true
  try {
    const params = {
      page: pagination.page,
      size: pagination.size,
      keyword: searchForm.keyword
    }
    const response = await userApi.listUsers(params)
    userList.value = response.data.items
    pagination.total = response.data.total
  } catch (error) {
    ElMessage.error('加载用户列表失败')
    console.error('Load user list error:', error)
  } finally {
    loading.value = false
  }
}

const handleSearch = () => {
  pagination.page = 1
  loadUserList()
}

const handleReset = () => {
  searchForm.keyword = ''
  pagination.page = 1
  loadUserList()
}

const handleCreate = () => {
  currentUser.value = null
  formVisible.value = true
}

const handleEdit = (user) => {
  currentUser.value = user
  formVisible.value = true
}

const handleDelete = async (user) => {
  try {
    await ElMessageBox.confirm(
      `确定要删除用户 "${user.username}" 吗？`,
      '确认删除',
      {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }
    )

    await userApi.deleteUser(user.id)
    ElMessage.success('删除成功')
    loadUserList()
  } catch (error) {
    if (error !== 'cancel') {
      ElMessage.error('删除失败')
      console.error('Delete user error:', error)
    }
  }
}

const handleFormSuccess = () => {
  formVisible.value = false
  loadUserList()
}

const handleSizeChange = (size) => {
  pagination.size = size
  pagination.page = 1
  loadUserList()
}

const handleCurrentChange = (page) => {
  pagination.page = page
  loadUserList()
}

// 生命周期
onMounted(() => {
  loadUserList()
})
</script>

<style scoped>
.user-list {
  padding: 20px;
}

.search-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding: 20px;
  background: #f5f5f5;
  border-radius: 4px;
}

.search-form {
  margin: 0;
}

.create-btn {
  margin-left: 20px;
}

.pagination {
  margin-top: 20px;
  text-align: right;
}
</style>
```

### 5.3 测试策略

#### 5.3.1 单元测试
```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @Mock
    private MessageQueue messageQueue;

    @InjectMocks
    private UserService userService;

    @Test
    @DisplayName("创建用户 - 成功")
    void shouldCreateUserSuccessfully() {
        // Given
        CreateUserRequest request = CreateUserRequest.builder()
            .username("testuser")
            .email("test@example.com")
            .password("password123")
            .build();

        User savedUser = User.builder()
            .id(1L)
            .username("testuser")
            .email("test@example.com")
            .password("encodedPassword")
            .status(UserStatus.ACTIVE)
            .createdAt(LocalDateTime.now())
            .build();

        when(userRepository.existsByUsername("testuser")).thenReturn(false);
        when(passwordEncoder.encode("password123")).thenReturn("encodedPassword");
        when(userRepository.save(any(User.class))).thenReturn(savedUser);

        // When
        UserDTO result = userService.createUser(request);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getUsername()).isEqualTo("testuser");
        assertThat(result.getEmail()).isEqualTo("test@example.com");
        assertThat(result.getStatus()).isEqualTo(UserStatus.ACTIVE);

        verify(messageQueue).send(eq("user.created"), any(UserCreatedEvent.class));
    }

    @Test
    @DisplayName("创建用户 - 用户名已存在")
    void shouldThrowExceptionWhenUsernameExists() {
        // Given
        CreateUserRequest request = CreateUserRequest.builder()
            .username("existinguser")
            .email("test@example.com")
            .password("password123")
            .build();

        when(userRepository.existsByUsername("existinguser")).thenReturn(true);

        // When & Then
        assertThatThrownBy(() -> userService.createUser(request))
            .isInstanceOf(BusinessException.class)
            .hasMessage("用户名已存在");
    }
}
```

#### 5.3.2 集成测试
```java
@SpringBootTest
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
@Transactional
class UserControllerIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private UserRepository userRepository;

    @Test
    @DisplayName("创建用户 API - 成功")
    void shouldCreateUserSuccessfully() {
        // Given
        CreateUserRequest request = CreateUserRequest.builder()
            .username("testuser")
            .email("test@example.com")
            .password("password123")
            .build();

        // When
        ResponseEntity<ApiResponse> response = restTemplate.postForEntity(
            "/api/users", request, ApiResponse.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getCode()).isEqualTo(200);

        Optional<User> savedUser = userRepository.findByUsername("testuser");
        assertThat(savedUser).isPresent();
        assertThat(savedUser.get().getEmail()).isEqualTo("test@example.com");
    }
}
```

### 5.4 监控和运维

#### 5.4.1 健康检查配置
```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
      probes:
        enabled: true
  health:
    redis:
      enabled: true
    db:
      enabled: true
    rabbitmq:
      enabled: true
```

#### 5.4.2 监控指标配置
```java
@Component
public class CustomMetrics {

    private final Counter userCreationCounter;
    private final Timer requestTimer;

    public CustomMetrics(MeterRegistry meterRegistry) {
        this.userCreationCounter = Counter.builder("user.creation.count")
            .description("Total number of users created")
            .register(meterRegistry);

        this.requestTimer = Timer.builder("api.request.duration")
            .description("API request duration")
            .register(meterRegistry);
    }

    public void incrementUserCreation() {
        userCreationCounter.increment();
    }

    public Timer.Sample startTimer() {
        return Timer.start();
    }

    public void recordTimer(Timer.Sample sample) {
        sample.stop(requestTimer);
    }
}
```

#### 5.4.3 日志配置
```yaml
# logback-spring.xml
<configuration>
    <springProfile name="!local">
        <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <message/>
                    <mdc/>
                    <arguments/>
                    <stackTrace/>
                </providers>
            </encoder>
        </appender>

        <root level="INFO">
            <appender-ref ref="STDOUT"/>
        </root>
    </springProfile>
</configuration>
```

## 6. 迁移指南

### 6.1 从单体到微服务迁移

#### 6.1.1 迁移步骤
1. **评估和规划**
   - 分析现有单体应用的模块依赖关系
   - 识别可以独立拆分的服务边界
   - 制定迁移时间表和风险控制策略

2. **基础设施准备**
   - 搭建微服务基础设施（注册中心、配置中心、网关等）
   - 建立监控和日志系统
   - 准备容器化环境

3. **逐步拆分**
   - 选择业务边界清晰的模块作为第一个拆分对象
   - 实现数据同步和双写机制
   - 逐步切换流量到新的微服务

4. **完善和优化**
   - 优化服务间通信
   - 完善监控和告警
   - 建立服务治理机制

#### 6.1.2 数据迁移策略
```java
// 数据同步服务
@Service
public class DataSyncService {

    @Autowired
    private UserMonolithRepository monolithRepository;

    @Autowired
    private UserMicroserviceRepository microserviceRepository;

    @Scheduled(fixedDelay = 60000) // 每分钟同步一次
    public void syncUserData() {
        LocalDateTime lastSyncTime = getLastSyncTime();

        // 查找同步时间之后更新的用户
        List<User> updatedUsers = monolithRepository.findUpdatedAfter(lastSyncTime);

        // 同步到微服务数据库
        for (User user : updatedUsers) {
            microserviceRepository.upsert(user);
        }

        // 更新同步时间戳
        updateLastSyncTime(LocalDateTime.now());
    }
}
```

### 6.2 从微服务到单体迁移

#### 6.2.1 合并策略
1. **代码合并**
   - 将各微服务的代码合并到一个单体项目中
   - 统一依赖管理和配置
   - 调整包结构和模块划分

2. **数据整合**
   - 合并多个数据库为一个
   - 处理数据冲突和一致性问题
   - 更新数据访问层代码

3. **配置调整**
   - 简化配置文件
   - 禁用微服务相关功能
   - 启用单体模式配置

#### 6.2.2 回滚计划
```bash
#!/bin/bash
# rollback.sh - 微服务回滚到单体部署脚本

echo "开始回滚部署..."

# 1. 停止微服务
docker-compose -f docker-compose.microservice.yml down

# 2. 备份当前数据
docker-compose -f docker-compose.backup.yml exec mysql mysqldump -u root -p business > backup_$(date +%Y%m%d_%H%M%S).sql

# 3. 启动单体应用
docker-compose -f docker-compose.monolith.yml up -d

# 4. 验证服务状态
sleep 30
curl -f http://localhost:8080/actuator/health || {
    echo "单体应用启动失败，执行回滚..."
    docker-compose -f docker-compose.monolith.yml down
    docker-compose -f docker-compose.microservice.yml up -d
    exit 1
}

echo "回滚完成！"
```

## 7. 最佳实践

### 7.1 开发最佳实践

#### 7.1.1 代码质量
- **代码审查**：所有代码变更都需要经过同行审查
- **自动化测试**：单元测试覆盖率不低于80%
- **静态代码分析**：使用 SonarQube 进行代码质量检查
- **文档维护**：及时更新技术文档和 API 文档

#### 7.1.2 安全实践
```java
// 安全配置
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/actuator/health").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### 7.2 运维最佳实践

#### 7.2.1 容器化最佳实践
```dockerfile
# 多阶段构建 Dockerfile
FROM maven:3.9-openjdk-17 AS builder

WORKDIR /app
COPY pom.xml .
COPY src ./src

RUN mvn clean package -DskipTests

FROM openjdk:17-jre-slim

# 创建非 root 用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

# 安装必要的工具
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 设置工作目录
WORKDIR /app

# 复制应用文件
COPY --from=builder /app/target/*.jar app.jar

# 创建日志目录
RUN mkdir -p /app/logs && chown -R appuser:appuser /app

# 切换到非 root 用户
USER appuser

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# 启动应用
ENTRYPOINT ["java", "-jar", "-Dspring.profiles.active=docker", "app.jar"]
```

#### 7.2.2 监控和告警
```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'business-app'
    static_configs:
      - targets: ['app:8080']
    metrics_path: '/actuator/prometheus'
    scrape_interval: 10s

  - job_name: 'mysql'
    static_configs:
      - targets: ['mysql-exporter:9104']

  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']

rule_files:
  - "alert_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

### 7.3 性能优化

#### 7.3.1 数据库优化
```sql
-- 创建适当的索引
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status_created ON users(status, created_at);

-- 分区表示例（按时间分区）
CREATE TABLE orders (
    id BIGINT AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id, created_at),
    INDEX idx_user_id (user_id),
    INDEX idx_status (status)
) PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);
```

#### 7.3.2 缓存优化
```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private CacheManager cacheManager;

    @Cacheable(value = "users", key = "#id", unless = "#result == null")
    public UserDTO getUser(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new BusinessException("用户不存在"));
        return UserDTO.from(user);
    }

    @CacheEvict(value = "users", key = "#id")
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }

    @CachePut(value = "users", key = "#result.id")
    public UserDTO updateUser(Long id, UpdateUserRequest request) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new BusinessException("用户不存在"));

        // 更新用户信息
        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());

        user = userRepository.save(user);
        return UserDTO.from(user);
    }
}
```

## 8. 总结

本技术架构设计文档提供了一个完整的模块化双模式架构解决方案，实现了以下核心目标：

### 8.1 架构优势
1. **灵活性**：支持微服务和单体两种部署模式，可根据实际需求灵活选择
2. **一致性**：业务逻辑在不同部署模式下保持一致，避免重复开发
3. **可扩展性**：模块化设计支持独立扩展和部署
4. **标准化**：统一的技术栈和开发规范降低学习成本
5. **云原生**：完全支持容器化和云原生部署

### 8.2 技术特点
- **抽象层设计**：通过抽象层屏蔽底层技术差异
- **配置驱动**：通过配置控制部署模式和运行时行为
- **渐进式迁移**：支持从单体到微服务的渐进式迁移
- **完整监控**：提供全面的监控和运维支持

### 8.3 适用场景
- **初创企业**：从单体应用开始，随着业务增长逐步迁移到微服务
- **传统企业**：现有单体应用的现代化改造
- **大型企业**：不同业务线采用不同的部署策略
- **SaaS 产品**：需要支持多种部署模式的软件产品

### 8.4 后续演进
1. **技术栈升级**：持续跟进技术发展，适时升级技术栈
2. **自动化提升**：加强 CI/CD 和自动化运维能力
3. **性能优化**：持续优化系统性能和资源利用率
4. **安全加固**：不断完善安全防护和合规要求

本架构设计为企业提供了一个可持续发展的技术基础，既满足了当前的业务需求，又为未来的发展预留了充足的空间。